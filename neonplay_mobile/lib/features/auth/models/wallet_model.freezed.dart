// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'wallet_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$WalletBalances {

@JsonKey(name: 'USD') double get usd;@JsonKey(name: 'EUR') double get eur;@JsonKey(name: 'GBP') double get gbp;@JsonKey(name: 'CAD') double get cad;@JsonKey(name: 'AUD') double get aud;@JsonKey(name: 'PHP') double get php;@JsonKey(name: 'INR') double get inr;@JsonKey(name: 'THB') double get thb;@JsonKey(name: 'CNY') double get cny;@JsonKey(name: 'JPY') double get jpy;@JsonKey(name: 'USDC') double get usdc;@JsonKey(name: 'USDT') double get usdt;@JsonKey(name: 'BTC') double get btc;@JsonKey(name: 'ETH') double get eth;@JsonKey(name: 'SOL') double get sol;@JsonKey(name: 'DOGE') double get doge;
/// Create a copy of WalletBalances
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WalletBalancesCopyWith<WalletBalances> get copyWith => _$WalletBalancesCopyWithImpl<WalletBalances>(this as WalletBalances, _$identity);

  /// Serializes this WalletBalances to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WalletBalances&&(identical(other.usd, usd) || other.usd == usd)&&(identical(other.eur, eur) || other.eur == eur)&&(identical(other.gbp, gbp) || other.gbp == gbp)&&(identical(other.cad, cad) || other.cad == cad)&&(identical(other.aud, aud) || other.aud == aud)&&(identical(other.php, php) || other.php == php)&&(identical(other.inr, inr) || other.inr == inr)&&(identical(other.thb, thb) || other.thb == thb)&&(identical(other.cny, cny) || other.cny == cny)&&(identical(other.jpy, jpy) || other.jpy == jpy)&&(identical(other.usdc, usdc) || other.usdc == usdc)&&(identical(other.usdt, usdt) || other.usdt == usdt)&&(identical(other.btc, btc) || other.btc == btc)&&(identical(other.eth, eth) || other.eth == eth)&&(identical(other.sol, sol) || other.sol == sol)&&(identical(other.doge, doge) || other.doge == doge));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,usd,eur,gbp,cad,aud,php,inr,thb,cny,jpy,usdc,usdt,btc,eth,sol,doge);

@override
String toString() {
  return 'WalletBalances(usd: $usd, eur: $eur, gbp: $gbp, cad: $cad, aud: $aud, php: $php, inr: $inr, thb: $thb, cny: $cny, jpy: $jpy, usdc: $usdc, usdt: $usdt, btc: $btc, eth: $eth, sol: $sol, doge: $doge)';
}


}

/// @nodoc
abstract mixin class $WalletBalancesCopyWith<$Res>  {
  factory $WalletBalancesCopyWith(WalletBalances value, $Res Function(WalletBalances) _then) = _$WalletBalancesCopyWithImpl;
@useResult
$Res call({
@JsonKey(name: 'USD') double usd,@JsonKey(name: 'EUR') double eur,@JsonKey(name: 'GBP') double gbp,@JsonKey(name: 'CAD') double cad,@JsonKey(name: 'AUD') double aud,@JsonKey(name: 'PHP') double php,@JsonKey(name: 'INR') double inr,@JsonKey(name: 'THB') double thb,@JsonKey(name: 'CNY') double cny,@JsonKey(name: 'JPY') double jpy,@JsonKey(name: 'USDC') double usdc,@JsonKey(name: 'USDT') double usdt,@JsonKey(name: 'BTC') double btc,@JsonKey(name: 'ETH') double eth,@JsonKey(name: 'SOL') double sol,@JsonKey(name: 'DOGE') double doge
});




}
/// @nodoc
class _$WalletBalancesCopyWithImpl<$Res>
    implements $WalletBalancesCopyWith<$Res> {
  _$WalletBalancesCopyWithImpl(this._self, this._then);

  final WalletBalances _self;
  final $Res Function(WalletBalances) _then;

/// Create a copy of WalletBalances
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? usd = null,Object? eur = null,Object? gbp = null,Object? cad = null,Object? aud = null,Object? php = null,Object? inr = null,Object? thb = null,Object? cny = null,Object? jpy = null,Object? usdc = null,Object? usdt = null,Object? btc = null,Object? eth = null,Object? sol = null,Object? doge = null,}) {
  return _then(_self.copyWith(
usd: null == usd ? _self.usd : usd // ignore: cast_nullable_to_non_nullable
as double,eur: null == eur ? _self.eur : eur // ignore: cast_nullable_to_non_nullable
as double,gbp: null == gbp ? _self.gbp : gbp // ignore: cast_nullable_to_non_nullable
as double,cad: null == cad ? _self.cad : cad // ignore: cast_nullable_to_non_nullable
as double,aud: null == aud ? _self.aud : aud // ignore: cast_nullable_to_non_nullable
as double,php: null == php ? _self.php : php // ignore: cast_nullable_to_non_nullable
as double,inr: null == inr ? _self.inr : inr // ignore: cast_nullable_to_non_nullable
as double,thb: null == thb ? _self.thb : thb // ignore: cast_nullable_to_non_nullable
as double,cny: null == cny ? _self.cny : cny // ignore: cast_nullable_to_non_nullable
as double,jpy: null == jpy ? _self.jpy : jpy // ignore: cast_nullable_to_non_nullable
as double,usdc: null == usdc ? _self.usdc : usdc // ignore: cast_nullable_to_non_nullable
as double,usdt: null == usdt ? _self.usdt : usdt // ignore: cast_nullable_to_non_nullable
as double,btc: null == btc ? _self.btc : btc // ignore: cast_nullable_to_non_nullable
as double,eth: null == eth ? _self.eth : eth // ignore: cast_nullable_to_non_nullable
as double,sol: null == sol ? _self.sol : sol // ignore: cast_nullable_to_non_nullable
as double,doge: null == doge ? _self.doge : doge // ignore: cast_nullable_to_non_nullable
as double,
  ));
}

}


/// Adds pattern-matching-related methods to [WalletBalances].
extension WalletBalancesPatterns on WalletBalances {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _WalletBalances value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _WalletBalances() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _WalletBalances value)  $default,){
final _that = this;
switch (_that) {
case _WalletBalances():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _WalletBalances value)?  $default,){
final _that = this;
switch (_that) {
case _WalletBalances() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function(@JsonKey(name: 'USD')  double usd, @JsonKey(name: 'EUR')  double eur, @JsonKey(name: 'GBP')  double gbp, @JsonKey(name: 'CAD')  double cad, @JsonKey(name: 'AUD')  double aud, @JsonKey(name: 'PHP')  double php, @JsonKey(name: 'INR')  double inr, @JsonKey(name: 'THB')  double thb, @JsonKey(name: 'CNY')  double cny, @JsonKey(name: 'JPY')  double jpy, @JsonKey(name: 'USDC')  double usdc, @JsonKey(name: 'USDT')  double usdt, @JsonKey(name: 'BTC')  double btc, @JsonKey(name: 'ETH')  double eth, @JsonKey(name: 'SOL')  double sol, @JsonKey(name: 'DOGE')  double doge)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _WalletBalances() when $default != null:
return $default(_that.usd,_that.eur,_that.gbp,_that.cad,_that.aud,_that.php,_that.inr,_that.thb,_that.cny,_that.jpy,_that.usdc,_that.usdt,_that.btc,_that.eth,_that.sol,_that.doge);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function(@JsonKey(name: 'USD')  double usd, @JsonKey(name: 'EUR')  double eur, @JsonKey(name: 'GBP')  double gbp, @JsonKey(name: 'CAD')  double cad, @JsonKey(name: 'AUD')  double aud, @JsonKey(name: 'PHP')  double php, @JsonKey(name: 'INR')  double inr, @JsonKey(name: 'THB')  double thb, @JsonKey(name: 'CNY')  double cny, @JsonKey(name: 'JPY')  double jpy, @JsonKey(name: 'USDC')  double usdc, @JsonKey(name: 'USDT')  double usdt, @JsonKey(name: 'BTC')  double btc, @JsonKey(name: 'ETH')  double eth, @JsonKey(name: 'SOL')  double sol, @JsonKey(name: 'DOGE')  double doge)  $default,) {final _that = this;
switch (_that) {
case _WalletBalances():
return $default(_that.usd,_that.eur,_that.gbp,_that.cad,_that.aud,_that.php,_that.inr,_that.thb,_that.cny,_that.jpy,_that.usdc,_that.usdt,_that.btc,_that.eth,_that.sol,_that.doge);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function(@JsonKey(name: 'USD')  double usd, @JsonKey(name: 'EUR')  double eur, @JsonKey(name: 'GBP')  double gbp, @JsonKey(name: 'CAD')  double cad, @JsonKey(name: 'AUD')  double aud, @JsonKey(name: 'PHP')  double php, @JsonKey(name: 'INR')  double inr, @JsonKey(name: 'THB')  double thb, @JsonKey(name: 'CNY')  double cny, @JsonKey(name: 'JPY')  double jpy, @JsonKey(name: 'USDC')  double usdc, @JsonKey(name: 'USDT')  double usdt, @JsonKey(name: 'BTC')  double btc, @JsonKey(name: 'ETH')  double eth, @JsonKey(name: 'SOL')  double sol, @JsonKey(name: 'DOGE')  double doge)?  $default,) {final _that = this;
switch (_that) {
case _WalletBalances() when $default != null:
return $default(_that.usd,_that.eur,_that.gbp,_that.cad,_that.aud,_that.php,_that.inr,_that.thb,_that.cny,_that.jpy,_that.usdc,_that.usdt,_that.btc,_that.eth,_that.sol,_that.doge);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _WalletBalances implements WalletBalances {
  const _WalletBalances({@JsonKey(name: 'USD') this.usd = 0, @JsonKey(name: 'EUR') this.eur = 0, @JsonKey(name: 'GBP') this.gbp = 0, @JsonKey(name: 'CAD') this.cad = 0, @JsonKey(name: 'AUD') this.aud = 0, @JsonKey(name: 'PHP') this.php = 0, @JsonKey(name: 'INR') this.inr = 0, @JsonKey(name: 'THB') this.thb = 0, @JsonKey(name: 'CNY') this.cny = 0, @JsonKey(name: 'JPY') this.jpy = 0, @JsonKey(name: 'USDC') this.usdc = 0, @JsonKey(name: 'USDT') this.usdt = 0, @JsonKey(name: 'BTC') this.btc = 0, @JsonKey(name: 'ETH') this.eth = 0, @JsonKey(name: 'SOL') this.sol = 0, @JsonKey(name: 'DOGE') this.doge = 0});
  factory _WalletBalances.fromJson(Map<String, dynamic> json) => _$WalletBalancesFromJson(json);

@override@JsonKey(name: 'USD') final  double usd;
@override@JsonKey(name: 'EUR') final  double eur;
@override@JsonKey(name: 'GBP') final  double gbp;
@override@JsonKey(name: 'CAD') final  double cad;
@override@JsonKey(name: 'AUD') final  double aud;
@override@JsonKey(name: 'PHP') final  double php;
@override@JsonKey(name: 'INR') final  double inr;
@override@JsonKey(name: 'THB') final  double thb;
@override@JsonKey(name: 'CNY') final  double cny;
@override@JsonKey(name: 'JPY') final  double jpy;
@override@JsonKey(name: 'USDC') final  double usdc;
@override@JsonKey(name: 'USDT') final  double usdt;
@override@JsonKey(name: 'BTC') final  double btc;
@override@JsonKey(name: 'ETH') final  double eth;
@override@JsonKey(name: 'SOL') final  double sol;
@override@JsonKey(name: 'DOGE') final  double doge;

/// Create a copy of WalletBalances
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WalletBalancesCopyWith<_WalletBalances> get copyWith => __$WalletBalancesCopyWithImpl<_WalletBalances>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WalletBalancesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WalletBalances&&(identical(other.usd, usd) || other.usd == usd)&&(identical(other.eur, eur) || other.eur == eur)&&(identical(other.gbp, gbp) || other.gbp == gbp)&&(identical(other.cad, cad) || other.cad == cad)&&(identical(other.aud, aud) || other.aud == aud)&&(identical(other.php, php) || other.php == php)&&(identical(other.inr, inr) || other.inr == inr)&&(identical(other.thb, thb) || other.thb == thb)&&(identical(other.cny, cny) || other.cny == cny)&&(identical(other.jpy, jpy) || other.jpy == jpy)&&(identical(other.usdc, usdc) || other.usdc == usdc)&&(identical(other.usdt, usdt) || other.usdt == usdt)&&(identical(other.btc, btc) || other.btc == btc)&&(identical(other.eth, eth) || other.eth == eth)&&(identical(other.sol, sol) || other.sol == sol)&&(identical(other.doge, doge) || other.doge == doge));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,usd,eur,gbp,cad,aud,php,inr,thb,cny,jpy,usdc,usdt,btc,eth,sol,doge);

@override
String toString() {
  return 'WalletBalances(usd: $usd, eur: $eur, gbp: $gbp, cad: $cad, aud: $aud, php: $php, inr: $inr, thb: $thb, cny: $cny, jpy: $jpy, usdc: $usdc, usdt: $usdt, btc: $btc, eth: $eth, sol: $sol, doge: $doge)';
}


}

/// @nodoc
abstract mixin class _$WalletBalancesCopyWith<$Res> implements $WalletBalancesCopyWith<$Res> {
  factory _$WalletBalancesCopyWith(_WalletBalances value, $Res Function(_WalletBalances) _then) = __$WalletBalancesCopyWithImpl;
@override @useResult
$Res call({
@JsonKey(name: 'USD') double usd,@JsonKey(name: 'EUR') double eur,@JsonKey(name: 'GBP') double gbp,@JsonKey(name: 'CAD') double cad,@JsonKey(name: 'AUD') double aud,@JsonKey(name: 'PHP') double php,@JsonKey(name: 'INR') double inr,@JsonKey(name: 'THB') double thb,@JsonKey(name: 'CNY') double cny,@JsonKey(name: 'JPY') double jpy,@JsonKey(name: 'USDC') double usdc,@JsonKey(name: 'USDT') double usdt,@JsonKey(name: 'BTC') double btc,@JsonKey(name: 'ETH') double eth,@JsonKey(name: 'SOL') double sol,@JsonKey(name: 'DOGE') double doge
});




}
/// @nodoc
class __$WalletBalancesCopyWithImpl<$Res>
    implements _$WalletBalancesCopyWith<$Res> {
  __$WalletBalancesCopyWithImpl(this._self, this._then);

  final _WalletBalances _self;
  final $Res Function(_WalletBalances) _then;

/// Create a copy of WalletBalances
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? usd = null,Object? eur = null,Object? gbp = null,Object? cad = null,Object? aud = null,Object? php = null,Object? inr = null,Object? thb = null,Object? cny = null,Object? jpy = null,Object? usdc = null,Object? usdt = null,Object? btc = null,Object? eth = null,Object? sol = null,Object? doge = null,}) {
  return _then(_WalletBalances(
usd: null == usd ? _self.usd : usd // ignore: cast_nullable_to_non_nullable
as double,eur: null == eur ? _self.eur : eur // ignore: cast_nullable_to_non_nullable
as double,gbp: null == gbp ? _self.gbp : gbp // ignore: cast_nullable_to_non_nullable
as double,cad: null == cad ? _self.cad : cad // ignore: cast_nullable_to_non_nullable
as double,aud: null == aud ? _self.aud : aud // ignore: cast_nullable_to_non_nullable
as double,php: null == php ? _self.php : php // ignore: cast_nullable_to_non_nullable
as double,inr: null == inr ? _self.inr : inr // ignore: cast_nullable_to_non_nullable
as double,thb: null == thb ? _self.thb : thb // ignore: cast_nullable_to_non_nullable
as double,cny: null == cny ? _self.cny : cny // ignore: cast_nullable_to_non_nullable
as double,jpy: null == jpy ? _self.jpy : jpy // ignore: cast_nullable_to_non_nullable
as double,usdc: null == usdc ? _self.usdc : usdc // ignore: cast_nullable_to_non_nullable
as double,usdt: null == usdt ? _self.usdt : usdt // ignore: cast_nullable_to_non_nullable
as double,btc: null == btc ? _self.btc : btc // ignore: cast_nullable_to_non_nullable
as double,eth: null == eth ? _self.eth : eth // ignore: cast_nullable_to_non_nullable
as double,sol: null == sol ? _self.sol : sol // ignore: cast_nullable_to_non_nullable
as double,doge: null == doge ? _self.doge : doge // ignore: cast_nullable_to_non_nullable
as double,
  ));
}


}


/// @nodoc
mixin _$LifetimeStats {

 double get deposited; double get withdrawn; double get wagered; double get won; double get bonuses;
/// Create a copy of LifetimeStats
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LifetimeStatsCopyWith<LifetimeStats> get copyWith => _$LifetimeStatsCopyWithImpl<LifetimeStats>(this as LifetimeStats, _$identity);

  /// Serializes this LifetimeStats to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LifetimeStats&&(identical(other.deposited, deposited) || other.deposited == deposited)&&(identical(other.withdrawn, withdrawn) || other.withdrawn == withdrawn)&&(identical(other.wagered, wagered) || other.wagered == wagered)&&(identical(other.won, won) || other.won == won)&&(identical(other.bonuses, bonuses) || other.bonuses == bonuses));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,deposited,withdrawn,wagered,won,bonuses);

@override
String toString() {
  return 'LifetimeStats(deposited: $deposited, withdrawn: $withdrawn, wagered: $wagered, won: $won, bonuses: $bonuses)';
}


}

/// @nodoc
abstract mixin class $LifetimeStatsCopyWith<$Res>  {
  factory $LifetimeStatsCopyWith(LifetimeStats value, $Res Function(LifetimeStats) _then) = _$LifetimeStatsCopyWithImpl;
@useResult
$Res call({
 double deposited, double withdrawn, double wagered, double won, double bonuses
});




}
/// @nodoc
class _$LifetimeStatsCopyWithImpl<$Res>
    implements $LifetimeStatsCopyWith<$Res> {
  _$LifetimeStatsCopyWithImpl(this._self, this._then);

  final LifetimeStats _self;
  final $Res Function(LifetimeStats) _then;

/// Create a copy of LifetimeStats
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? deposited = null,Object? withdrawn = null,Object? wagered = null,Object? won = null,Object? bonuses = null,}) {
  return _then(_self.copyWith(
deposited: null == deposited ? _self.deposited : deposited // ignore: cast_nullable_to_non_nullable
as double,withdrawn: null == withdrawn ? _self.withdrawn : withdrawn // ignore: cast_nullable_to_non_nullable
as double,wagered: null == wagered ? _self.wagered : wagered // ignore: cast_nullable_to_non_nullable
as double,won: null == won ? _self.won : won // ignore: cast_nullable_to_non_nullable
as double,bonuses: null == bonuses ? _self.bonuses : bonuses // ignore: cast_nullable_to_non_nullable
as double,
  ));
}

}


/// Adds pattern-matching-related methods to [LifetimeStats].
extension LifetimeStatsPatterns on LifetimeStats {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _LifetimeStats value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _LifetimeStats() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _LifetimeStats value)  $default,){
final _that = this;
switch (_that) {
case _LifetimeStats():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _LifetimeStats value)?  $default,){
final _that = this;
switch (_that) {
case _LifetimeStats() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( double deposited,  double withdrawn,  double wagered,  double won,  double bonuses)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _LifetimeStats() when $default != null:
return $default(_that.deposited,_that.withdrawn,_that.wagered,_that.won,_that.bonuses);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( double deposited,  double withdrawn,  double wagered,  double won,  double bonuses)  $default,) {final _that = this;
switch (_that) {
case _LifetimeStats():
return $default(_that.deposited,_that.withdrawn,_that.wagered,_that.won,_that.bonuses);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( double deposited,  double withdrawn,  double wagered,  double won,  double bonuses)?  $default,) {final _that = this;
switch (_that) {
case _LifetimeStats() when $default != null:
return $default(_that.deposited,_that.withdrawn,_that.wagered,_that.won,_that.bonuses);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _LifetimeStats implements LifetimeStats {
  const _LifetimeStats({this.deposited = 0, this.withdrawn = 0, this.wagered = 0, this.won = 0, this.bonuses = 0});
  factory _LifetimeStats.fromJson(Map<String, dynamic> json) => _$LifetimeStatsFromJson(json);

@override@JsonKey() final  double deposited;
@override@JsonKey() final  double withdrawn;
@override@JsonKey() final  double wagered;
@override@JsonKey() final  double won;
@override@JsonKey() final  double bonuses;

/// Create a copy of LifetimeStats
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LifetimeStatsCopyWith<_LifetimeStats> get copyWith => __$LifetimeStatsCopyWithImpl<_LifetimeStats>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LifetimeStatsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LifetimeStats&&(identical(other.deposited, deposited) || other.deposited == deposited)&&(identical(other.withdrawn, withdrawn) || other.withdrawn == withdrawn)&&(identical(other.wagered, wagered) || other.wagered == wagered)&&(identical(other.won, won) || other.won == won)&&(identical(other.bonuses, bonuses) || other.bonuses == bonuses));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,deposited,withdrawn,wagered,won,bonuses);

@override
String toString() {
  return 'LifetimeStats(deposited: $deposited, withdrawn: $withdrawn, wagered: $wagered, won: $won, bonuses: $bonuses)';
}


}

/// @nodoc
abstract mixin class _$LifetimeStatsCopyWith<$Res> implements $LifetimeStatsCopyWith<$Res> {
  factory _$LifetimeStatsCopyWith(_LifetimeStats value, $Res Function(_LifetimeStats) _then) = __$LifetimeStatsCopyWithImpl;
@override @useResult
$Res call({
 double deposited, double withdrawn, double wagered, double won, double bonuses
});




}
/// @nodoc
class __$LifetimeStatsCopyWithImpl<$Res>
    implements _$LifetimeStatsCopyWith<$Res> {
  __$LifetimeStatsCopyWithImpl(this._self, this._then);

  final _LifetimeStats _self;
  final $Res Function(_LifetimeStats) _then;

/// Create a copy of LifetimeStats
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? deposited = null,Object? withdrawn = null,Object? wagered = null,Object? won = null,Object? bonuses = null,}) {
  return _then(_LifetimeStats(
deposited: null == deposited ? _self.deposited : deposited // ignore: cast_nullable_to_non_nullable
as double,withdrawn: null == withdrawn ? _self.withdrawn : withdrawn // ignore: cast_nullable_to_non_nullable
as double,wagered: null == wagered ? _self.wagered : wagered // ignore: cast_nullable_to_non_nullable
as double,won: null == won ? _self.won : won // ignore: cast_nullable_to_non_nullable
as double,bonuses: null == bonuses ? _self.bonuses : bonuses // ignore: cast_nullable_to_non_nullable
as double,
  ));
}


}


/// @nodoc
mixin _$WalletModel {

 WalletBalances get balances; String get primaryCurrency; LifetimeStats? get lifetimeStats;
/// Create a copy of WalletModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WalletModelCopyWith<WalletModel> get copyWith => _$WalletModelCopyWithImpl<WalletModel>(this as WalletModel, _$identity);

  /// Serializes this WalletModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WalletModel&&(identical(other.balances, balances) || other.balances == balances)&&(identical(other.primaryCurrency, primaryCurrency) || other.primaryCurrency == primaryCurrency)&&(identical(other.lifetimeStats, lifetimeStats) || other.lifetimeStats == lifetimeStats));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,balances,primaryCurrency,lifetimeStats);

@override
String toString() {
  return 'WalletModel(balances: $balances, primaryCurrency: $primaryCurrency, lifetimeStats: $lifetimeStats)';
}


}

/// @nodoc
abstract mixin class $WalletModelCopyWith<$Res>  {
  factory $WalletModelCopyWith(WalletModel value, $Res Function(WalletModel) _then) = _$WalletModelCopyWithImpl;
@useResult
$Res call({
 WalletBalances balances, String primaryCurrency, LifetimeStats? lifetimeStats
});


$WalletBalancesCopyWith<$Res> get balances;$LifetimeStatsCopyWith<$Res>? get lifetimeStats;

}
/// @nodoc
class _$WalletModelCopyWithImpl<$Res>
    implements $WalletModelCopyWith<$Res> {
  _$WalletModelCopyWithImpl(this._self, this._then);

  final WalletModel _self;
  final $Res Function(WalletModel) _then;

/// Create a copy of WalletModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? balances = null,Object? primaryCurrency = null,Object? lifetimeStats = freezed,}) {
  return _then(_self.copyWith(
balances: null == balances ? _self.balances : balances // ignore: cast_nullable_to_non_nullable
as WalletBalances,primaryCurrency: null == primaryCurrency ? _self.primaryCurrency : primaryCurrency // ignore: cast_nullable_to_non_nullable
as String,lifetimeStats: freezed == lifetimeStats ? _self.lifetimeStats : lifetimeStats // ignore: cast_nullable_to_non_nullable
as LifetimeStats?,
  ));
}
/// Create a copy of WalletModel
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WalletBalancesCopyWith<$Res> get balances {
  
  return $WalletBalancesCopyWith<$Res>(_self.balances, (value) {
    return _then(_self.copyWith(balances: value));
  });
}/// Create a copy of WalletModel
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LifetimeStatsCopyWith<$Res>? get lifetimeStats {
    if (_self.lifetimeStats == null) {
    return null;
  }

  return $LifetimeStatsCopyWith<$Res>(_self.lifetimeStats!, (value) {
    return _then(_self.copyWith(lifetimeStats: value));
  });
}
}


/// Adds pattern-matching-related methods to [WalletModel].
extension WalletModelPatterns on WalletModel {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _WalletModel value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _WalletModel() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _WalletModel value)  $default,){
final _that = this;
switch (_that) {
case _WalletModel():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _WalletModel value)?  $default,){
final _that = this;
switch (_that) {
case _WalletModel() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( WalletBalances balances,  String primaryCurrency,  LifetimeStats? lifetimeStats)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _WalletModel() when $default != null:
return $default(_that.balances,_that.primaryCurrency,_that.lifetimeStats);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( WalletBalances balances,  String primaryCurrency,  LifetimeStats? lifetimeStats)  $default,) {final _that = this;
switch (_that) {
case _WalletModel():
return $default(_that.balances,_that.primaryCurrency,_that.lifetimeStats);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( WalletBalances balances,  String primaryCurrency,  LifetimeStats? lifetimeStats)?  $default,) {final _that = this;
switch (_that) {
case _WalletModel() when $default != null:
return $default(_that.balances,_that.primaryCurrency,_that.lifetimeStats);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _WalletModel implements WalletModel {
  const _WalletModel({required this.balances, this.primaryCurrency = 'USD', this.lifetimeStats});
  factory _WalletModel.fromJson(Map<String, dynamic> json) => _$WalletModelFromJson(json);

@override final  WalletBalances balances;
@override@JsonKey() final  String primaryCurrency;
@override final  LifetimeStats? lifetimeStats;

/// Create a copy of WalletModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WalletModelCopyWith<_WalletModel> get copyWith => __$WalletModelCopyWithImpl<_WalletModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WalletModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WalletModel&&(identical(other.balances, balances) || other.balances == balances)&&(identical(other.primaryCurrency, primaryCurrency) || other.primaryCurrency == primaryCurrency)&&(identical(other.lifetimeStats, lifetimeStats) || other.lifetimeStats == lifetimeStats));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,balances,primaryCurrency,lifetimeStats);

@override
String toString() {
  return 'WalletModel(balances: $balances, primaryCurrency: $primaryCurrency, lifetimeStats: $lifetimeStats)';
}


}

/// @nodoc
abstract mixin class _$WalletModelCopyWith<$Res> implements $WalletModelCopyWith<$Res> {
  factory _$WalletModelCopyWith(_WalletModel value, $Res Function(_WalletModel) _then) = __$WalletModelCopyWithImpl;
@override @useResult
$Res call({
 WalletBalances balances, String primaryCurrency, LifetimeStats? lifetimeStats
});


@override $WalletBalancesCopyWith<$Res> get balances;@override $LifetimeStatsCopyWith<$Res>? get lifetimeStats;

}
/// @nodoc
class __$WalletModelCopyWithImpl<$Res>
    implements _$WalletModelCopyWith<$Res> {
  __$WalletModelCopyWithImpl(this._self, this._then);

  final _WalletModel _self;
  final $Res Function(_WalletModel) _then;

/// Create a copy of WalletModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? balances = null,Object? primaryCurrency = null,Object? lifetimeStats = freezed,}) {
  return _then(_WalletModel(
balances: null == balances ? _self.balances : balances // ignore: cast_nullable_to_non_nullable
as WalletBalances,primaryCurrency: null == primaryCurrency ? _self.primaryCurrency : primaryCurrency // ignore: cast_nullable_to_non_nullable
as String,lifetimeStats: freezed == lifetimeStats ? _self.lifetimeStats : lifetimeStats // ignore: cast_nullable_to_non_nullable
as LifetimeStats?,
  ));
}

/// Create a copy of WalletModel
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WalletBalancesCopyWith<$Res> get balances {
  
  return $WalletBalancesCopyWith<$Res>(_self.balances, (value) {
    return _then(_self.copyWith(balances: value));
  });
}/// Create a copy of WalletModel
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LifetimeStatsCopyWith<$Res>? get lifetimeStats {
    if (_self.lifetimeStats == null) {
    return null;
  }

  return $LifetimeStatsCopyWith<$Res>(_self.lifetimeStats!, (value) {
    return _then(_self.copyWith(lifetimeStats: value));
  });
}
}

// dart format on
